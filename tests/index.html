<!DOCTYPE html>
<html lang="en">

<head>

<meta charset="utf-8">
<title>Testing the extensions</title>

<link rel="stylesheet" href="CSS/tests.css">
<script src="../core.js"></script>
<script src="../extensions/framework.js"></script>
<script src="test-suite.js"></script>

<script>
(function () {

    'use strict';

    var $a = Core.get('array'),
        $c = Core.get('class'),
        $f = Core.get('function'),
        $n = Core.get('number'),
        $o = Core.get('object'),
        $s = Core.get('string');

    // $a.chunk(array, size = 1[, map[, context]]) -> Array
    TEST('$a.chunk', function (it) {

        var array = [1, 2, 3, 4, 5];

        it('should not affect the original array', function (assert) {

            $a.chunk(array, 2);

            assert.isSimilar(array, [1, 2, 3, 4, 5]);

        });

        it('should split arrays into smaller arrays', function (assert) {

            assert.isSimilar($a.chunk(array, 1), [[1], [2], [3], [4], [5]]);
            assert.isSimilar($a.chunk(array, 2), [[1, 2], [3, 4], [5]]);
            assert.isSimilar($a.chunk(array, 3), [[1, 2, 3], [4, 5]]);

        });

        it('should correct size to 1 if ommited, negative or not numeric', function (assert) {

            var slice1 = $a.chunk(array, 1);

            assert.isSimilar($a.chunk(array),      slice1);
            assert.isSimilar($a.chunk(array, -2),  slice1);
            assert.isSimilar($a.chunk(array, 'a'), slice1);

        });

        it('should allow values to be mapped', function (assert) {

            function double(n) {
                return n * 2;
            }

            assert.isSimilar(
                $a.chunk(array, 2, double),
                [[2, 4], [6, 8], [10]]
            );

            assert.isSimilar(
                $a.chunk(array, 3, double),
                [[2, 4, 6], [8, 10]]
            );

        });

    });

    // $a.compact(array) -> Array
    TEST('$a.compact', function (it) {

        var obj = {
                '0': 0,
                '1': 1,
                '2': 2,
                '3': null,
                '4': 4,
                '5': undefined,
                '6': 6,
                length: 7
            },
            arr = Array.prototype.slice.call(obj);

        it('should remove null and undefined', function (assert) {

            assert.isSimilar($a.compact(arr), [0, 1, 2, 4, 6]);
            assert.isSimilar($a.compact(obj), [0, 1, 2, 4, 6]);

        });

        it('should remove deleted entries', function (assert) {

            delete obj[1];
            delete arr[1];

            assert.isSimilar($a.compact(arr), [0, 2, 4, 6]);
            assert.isSimilar($a.compact(obj), [0, 2, 4, 6]);

        });

    });

    // $a.every(array, check[, context]) -> Boolean
    TEST('$a.every', function (it) {

        function isNumber(n) {
            return typeof n === 'number';
        }

        it('should check arrays properly', function (assert) {

            assert.isTrue($a.every([1, 2, 3], isNumber));
            assert.isFalse($a.every([1, 2, 3, 'a'], isNumber));

        });

        it('should check Array-like objects properly', function (assert) {

            assert.isTrue(
                $a.every({'0': 0, '1': 1, '2': 2, length: 3}, isNumber)
            );

            assert.isFalse(
                $a.every(
                    {'0': 0, '1': 1, '2': 2, '3': 'a', length: 4},
                    isNumber
                )
            );

        });

        it('should throw an error for non-function checks', function (assert) {

            assert.throws(function () {
                $a.every([1, 2, 3], 0);
            });

        });

    });

    // $a.filter(array, handler[, context]) -> Array
    TEST('$a.filter', function (it) {

        var obj = {
                '0': true,
                '1': 2,
                '2': '5',
                '3': 'ten',
                '4': 6,
                '5': null,
                length: 6
            },
            arr = Array.prototype.slice.call(obj);

        function isNumber(o) {
            return typeof o === 'number';
        }

        it('should filter entries in an Array or Array-like object', function (assert) {

            assert.isSimilar($a.filter(arr, isNumber), [2, 6]);
            assert.isSimilar($a.filter(obj, isNumber), [2, 6]);

        });

    });

    // $a.first(o[, filter[, context]]) -> ?
    TEST('$a.first', function (it) {

        var obj = {
                '0': true,
                '1': 2,
                '2': '5',
                '3': 'ten',
                '4': 6,
                '5': null,
                length: 6
            },
            arr = Array.prototype.slice.call(obj);

        it('should return the first entry of an Array or Array-like object', function (assert) {

            assert.isSame($a.first(arr), true);
            assert.isSame($a.first(obj), true);

        });

        it('should return the first match in the Array or Array-like object', function (assert) {

            function isNumber(o) {
                return typeof o === 'number';
            }

            assert.isSame($a.first(arr, isNumber), 2);
            assert.isSame($a.first(obj, isNumber), 2);

        });

        it('should return undefined if no match is found', function (assert) {

            function isZero(o) {
                return o === 0;
            }

            assert.isSame($a.first(arr, isZero), undefined);
            assert.isSame($a.first(obj, isZero), undefined);

        });

        it('should return the first entry if a non-function filter is passed', function (assert) {

            assert.isSame($a.first(arr, 0), true);
            assert.isSame($a.first(obj, 0), true);

        });

    });

    // $a.forEach(arr, handler[, context])
    TEST('$a.forEach', function (it) {

        var obj = {'0': 0, '1': 1, '2': 2, '3': 3, length: 4},
            arr = Array.prototype.slice.call(obj);

        it('should loop over Arrays and Array-like objects', function (assert) {

            var o1 = [],
                o2 = [];

            function push(a) {
                this.push(a);
            }

            $a.forEach(arr, push, o1);
            $a.forEach(obj, push, o2);

            assert.isSimilar(o1, arr);
            assert.isSimilar(o2, arr);

        });

        it('should stop the loop if false is returned', function (assert) {

            var o1 = [],
                o2 = [];

            function push(a) {
                this.push(a);
                return a !== 2;
            }

            $a.forEach(arr, push, o1);
            $a.forEach(obj, push, o2);

            assert.isSimilar(o1, [0, 1, 2]);
            assert.isSimilar(o2, [0, 1, 2]);


        });

        it('should throw an error if no function or a non-function is passed', function (assert) {

            assert.throws(function () {
                $a.forEach(arr);
            });

            assert.throws(function () {
                $a.forEach(arr, 0);
            });

            assert.throws(function () {
                $a.forEach(obj);
            });

            assert.throws(function () {
                $a.forEach(obj, 0);
            });

        });

    });

    // $a.from(o) -> Array
    TEST('$a.from', function (it) {

        var obj = {'0': 0, '1': 1, '2': 2, '3': 3, length: 4},
            arr = Array.prototype.slice.call(obj);

        it('should convert Arrays and Array-like objects', function (assert) {

            assert.isSimilar($a.from(arr), arr);
            assert.isSimilar($a.from(obj), arr);
            assert.isSimilar($a.from(arr.join('')), ['0', '1', '2', '3']);

        });

        it('should allow the values to be mapped', function (assert) {

            function double(n) {
                return n * 2;
            }

            var expected = [0, 2, 4, 6];

            assert.isSimilar($a.from(arr, double), expected);
            assert.isSimilar($a.from(obj, double), expected);

        });

        it('should convert non Array-like objects into empty Arrays', function (assert) {

            assert.isSimilar($a.from(123), []);
            assert.isSimilar($a.from(true), []);

        });

        it('should throw an error for null and undefined', function (assert) {

            assert.throws(function () { $a.from(null); });
            assert.throws(function () { $a.from(undefined); });

        });

    });

    // $a.indiciesOf(array, search[, offset]) -> Array
    TEST('$a.indiciesOf', function (it) {

        var obj = {
                '0': 'a',
                '1': 2,
                '2': true,
                '3': 'a',
                '4': null,
                '5': 10,
                '6': 'a',
                length: 7
            },
            arr = Array.prototype.slice.call(obj);

        it('should find all indicies in Arrays or Array-like objects', function (assert) {

            assert.isSimilar($a.indiciesOf(arr, 'a'), [0, 3, 6]);
            assert.isSimilar($a.indiciesOf(obj, 'a'), [0, 3, 6]);

        });

        it('should return an empty array for no matches', function (assert) {

            assert.isSimilar($a.indiciesOf(arr, 'b'), []);
            assert.isSimilar($a.indiciesOf(obj, 'b'), []);

            assert.isSimilar($a.indiciesOf(arr), []);
            assert.isSimilar($a.indiciesOf(obj), []);

        });

        it('should allow offsets to be defined', function (assert) {

            assert.isSimilar($a.indiciesOf(arr, 'a', 1), [3, 6]);
            assert.isSimilar($a.indiciesOf(obj, 'a', 1), [3, 6]);

        });

    });

    // $a.invoke(array, method) -> Array
    TEST('$a.invoke', function (it) {

        var obj = {
                '0': 'zero',
                '1': 'one',
                '2': 'two',
                '3': 'three',
                length: 4
            },
            arr = Array.prototype.slice.call(obj);

        it('should invoke the method on all entries', function (assert) {

            assert.isSimilar(
                $a.invoke(arr, 'toUpperCase'),
                ['ZERO', 'ONE', 'TWO', 'THREE']
            );

            assert.isSimilar(
                $a.invoke(obj, 'toUpperCase'),
                ['ZERO', 'ONE', 'TWO', 'THREE']
            );

        });

        it('should allow arguments to be passed to the method', function (assert) {

            assert.isSimilar(
                $a.invoke(arr, 'slice', 1),
                ['ero', 'ne', 'wo', 'hree']
            );

            assert.isSimilar(
                $a.invoke(obj, 'slice', 1),
                ['ero', 'ne', 'wo', 'hree']
            );

        });

        it('should throw errors if the method doesn\'t exist', function (assert) {

            assert.throws(function () { $a.invoke(arr, 'not_real'); });
            assert.throws(function () { $a.invoke(obj, 'not_real'); });

        });

    });

    // $a.isArray(o) -> Boolean
    TEST('$a.isArray', function (it) {

        var obj = {
                '0': 'zero',
                '1': 'one',
                '2': 'two',
                '3': 'three',
                length: 4
            },
            arr = Array.prototype.slice.call(obj);

        it('should correctly identify Arrays', function (assert) {

            assert.isTrue($a.isArray(arr));
            assert.isFalse($a.isArray(obj));

        });

    });

    // $a.isArrayLike(o) -> Boolean
    TEST('$a.isArrayLike', function (it) {

        it('should correctly identify Array-like objects', function (assert) {

            assert.isTrue($a.isArrayLike({length: '0'}));
            assert.isTrue($a.isArrayLike(arguments));
            assert.isTrue($a.isArrayLike(document.getElementsByTagName('a')));
            assert.isTrue($a.isArrayLike('string'));
            assert.isTrue($a.isArrayLike(''));
            assert.isTrue($a.isArrayLike([]));

            assert.isFalse($a.isArrayLike(true));
            assert.isFalse($a.isArrayLike(false));
            assert.isFalse($a.isArrayLike({foo: 1}));
            assert.isFalse($a.isArrayLike(10));
            assert.isFalse($a.isArrayLike(0));

        });

    });

    // $a.last(o[, filter[, context]]) -> ?
    TEST('$a.last', function (it) {

        var obj = {
                '0': true,
                '1': 2,
                '2': '5',
                '3': 'ten',
                '4': 6,
                '5': null,
                length: 6
            },
            arr = Array.prototype.slice.call(obj);

        it('should return the last entry of an Array or Array-like object', function (assert) {

            assert.isSame($a.last(arr), null);
            assert.isSame($a.last(obj), null);

        });

        it('should return the last match in the Array or Array-like object', function (assert) {

            function isNumber(o) {
                return typeof o === 'number';
            }

            assert.isSame($a.last(arr, isNumber), 6);
            assert.isSame($a.last(obj, isNumber), 6);

        });

        it('should return undefined if no match is found', function (assert) {

            function isZero(o) {
                return o === 0;
            }

            assert.isSame($a.last(arr, isZero), undefined);
            assert.isSame($a.last(obj, isZero), undefined);

        });

        it('should return the last entry if a non-function filter is passed', function (assert) {

            assert.isSame($a.last(arr, 0), null);
            assert.isSame($a.last(obj, 0), null);

        });

    });

    // $a.makeInvoker(context) -> Function
    TEST('$a.makeInvoker', function (it) {

        it('should create a function bound to a certain context', function (assert) {

            var context = {

                    add: function (a, b) {
                        return a + b;
                    },

                    add5: function (a) {
                        return this.add(a, 5);
                    }

                },

                invoker = $a.makeInvoker(context);

            assert.isSimilar(invoker([1, 2, 3], 'add5'), [6, 7, 8]);

        });

    });

    // $a.map(array, handler[, context]) -> Array
    TEST('$a.map', function (it) {

        var obj = {
                '0': 0,
                '1': 1,
                '2': 2,
                '3': 3,
                length: 4
            },
            arr = Array.prototype.slice.call(obj);

        function double(n) {
            return n * 2;
        }

        it('should work on Arrays and Array-like objects', function (assert) {

            assert.isSimilar($a.map(arr, double), [0, 2, 4, 6]);
            assert.isSimilar($a.map(obj, double), [0, 2, 4, 6]);

        });

    });

    // $a.partition(array, handler[, context]) -> Array
    TEST('$a.partition', function (it) {

        var obj = {
                '0': 1,
                '1': '1',
                length: 2
            },
            arr = Array.prototype.slice.call(obj);

        function isNumber(o) {
            return typeof o === 'number';
        }

        it('should divide Arrays and Array-like objects', function (assert) {

            assert.isSimilar($a.partition(arr, isNumber), [[1], ['1']]);
            assert.isSimilar($a.partition(obj, isNumber), [[1], ['1']]);

        });

    });

    // $a.pluck(array, property[, value]) -> Array|Object
    TEST('$a.pluck', function (it) {

        var obj = {
                '0': {text: 'zero', value: 0},
                '1': {text: 'one', value: 1},
                '2': {text: 'two', value: 2},
                '3': {text: 'three', value: 3},
                '4': {text: 'four', value: 4},
                '5': {text: 'five', value: 5},
                length: 6
            },
            arr = Array.prototype.slice.call(obj);

        it('should get properties from Arrays or Array-like objects', function (assert) {

            assert.isSimilar($a.pluck(arr, 'value'), [0, 1, 2, 3, 4, 5]);
            assert.isSimilar($a.pluck(obj, 'value'), [0, 1, 2, 3, 4, 5]);

        });

        it('should create generated objects', function (assert) {

            var generated = {
                zero:  0,
                one:   1,
                two:   2,
                three: 3,
                four:  4,
                five:  5
            };

            assert.isSimilar($a.pluck(arr, 'text', 'value'), generated);
            assert.isSimilar($a.pluck(obj, 'text', 'value'), generated);

        });

    });

    // $a.remove(array) -> Array
    TEST('$a.remove', function (it) {

        var obj = {
                '0': 0,
                '1': 1,
                '2': 2,
                '3': 3,
                length: 4
            },
            arr = Array.prototype.slice.call(obj);

        it('should remove entries from Arrays or Array-like objects', function (assert) {

            assert.isSimilar($a.remove(arr, 1, 2), [0, 3]);
            assert.isSimilar($a.remove(obj, 1, 2), [0, 3]);

        });

        it('should return the original array if no matches are found', function (assert) {

            assert.isSimilar($a.remove(arr, 4), arr);
            assert.isSimilar($a.remove(obj, 4), arr);

            assert.isSimilar($a.remove(arr), arr);
            assert.isSimilar($a.remove(obj), arr);

        });

    });

    // $a.shuffle(array) -> Array
    TEST('$a.shuffle', function (it) {

        var obj = {
                '0': 0,
                '1': 1,
                '2': 2,
                '3': 3,
                length: 4
            },
            arr = Array.prototype.slice.call(obj);

        it('should shuffle Arrays or Array-like objects', function (assert) {

            assert.isNotSimilar($a.shuffle(arr), arr);
            assert.isNotSimilar($a.shuffle(obj), arr);

        });

    });

    // $a.slice(arrayLike[, begin[, end]]) -> Array
    TEST('$a.slice', function (it) {

        var obj = {
                '0': 0,
                '1': 1,
                '2': 2,
                '3': 3,
                '4': 4,
                '5': 5,
                length: 6
            },
            arr = Array.prototype.slice.call(obj);

        it('should copy the array if no arguments are provided', function (assert) {

            var sliceA = $a.slice(arr),
                sliceO = $a.slice(obj);

            assert.isSimilar(sliceA, arr);
            assert.isSimilar(sliceO, arr);
            assert.isNotSame(sliceA, arr);
            assert.isNotSame(sliceO, arr);

        });

        it('should ignore entries before the first argument', function (assert) {

            assert.isSimilar($a.slice(arr, 1), [1, 2, 3, 4, 5]);
            assert.isSimilar($a.slice(obj, 1), [1, 2, 3, 4, 5]);

        });

        it('should ignore from end for negative first arguments', function (assert) {

            assert.isSimilar($a.slice(arr, -1), [5]);
            assert.isSimilar($a.slice(obj, -1), [5]);

        });

        it('should remove entries after the last argument', function (assert) {

            assert.isSimilar($a.slice(arr, 0, 1), [0]);
            assert.isSimilar($a.slice(obj, 0, 1), [0]);

        });

        it('should remove entries from the end for negative last arguments', function (assert) {

            assert.isSimilar($a.slice(arr, 0, -1), [0, 1, 2, 3, 4]);
            assert.isSimilar($a.slice(obj, 0, -1), [0, 1, 2, 3, 4]);

        });

    });

    // $a.some(o, test) -> Boolean
    TEST('$a.some', function (it) {

        var obj = {
                '0': 1,
                '1': 2,
                '2': 3,
                length: 3
            },
            arr = Array.prototype.slice.call(obj);

        function isUnder2(n) {
            return n < 2;
        }

        it('should check Arrays and Array-like object', function (assert) {

            assert.isTrue($a.some(arr, isUnder2));
            assert.isTrue($a.some(obj, isUnder2));

        });

        it('should throw an error if no function or a non-function is passed', function (assert) {

            assert.throws(function () { $a.some(arr, 0); });
            assert.throws(function () { $a.some(arr); });

        });

    });

    // $c.create([Base, ]proto) -> Function
    TEST('$c.create', function (it) {

        var Foo = $c.create({

            init: function (name) {
                this.name = name;
            }

        });

        var Bar = $c.create(Foo, {

            setType: function (type) {
                this.type = type;
            }

        });

        var Baz = $c.create(Bar, {

            setType: function (type1, type2) {

                this.$super(type1);
                this.otherType = type2;

            }

        });

        var Blip = $c.create(Bar, {

            setProp: function (prop) {
                this.prop = prop;
            }

        });

        var foo  = new Foo('foo');
        var bar  = new Bar('bar');
        var baz  = new Baz('baz');
        var blip = new Blip('blip');

        bar.setType('child');
        baz.setType('child', 'grandchild');

        Blip.addMethod('setType', function (one, two) {
            this.$super(one);
            this.other = two;
        });

        blip.setType('one', 'two');

        it('should use init as a constructor function', function (assert) {

            assert.isSame(foo.name, 'foo');
            assert.isTrue(foo instanceof Foo);

        });

        it('should allow inheritance', function (assert) {

            assert.isSame(bar.name, 'bar');
            assert.isSame(bar.type, 'child');
            assert.isTrue(bar instanceof Foo);
            assert.isTrue(bar instanceof Bar);

        });

        it('should allow the $super magic method', function (assert) {

            assert.isSame(baz.name, 'baz');
            assert.isSame(baz.type, 'child');
            assert.isSame(baz.otherType, 'grandchild');
            assert.isTrue(baz instanceof Foo);
            assert.isTrue(baz instanceof Bar);
            assert.isTrue(baz instanceof Baz);

        });

        it('should give classes an addMethod static method', function (assert) {

            assert.isSame(blip.name, 'blip');
            assert.isSame(blip.type, 'one');
            assert.isSame(blip.other, 'two');

        });

        it('should allow classes to be cloned', function (assert) {

            var clone1 = foo.$clone(),
                clone2 = bar.$clone();

            var Inner = $c.create(Foo, {

                init: function (name, name2) {

                    this.$super(name);
                    this.name2 = name2;

                }

            });

            var inner = new Inner('inner', 'inner2'),
                clone3 = inner.$clone();

            assert.isNotSame(foo, clone1);
            assert.isSame(foo.name, clone1.name);

            assert.isNotSame(bar, clone2);
            assert.isSame(bar.name, clone2.name);
            assert.isSame(bar.type, clone2.type);

            assert.isNotSame(inner, clone3);
            assert.isSame(inner.name, clone3.name);
            assert.isSame(inner.name2, clone3.name2);

        });

    });

    // $f.debounce(func[, wait = 100]) -> Function
    TEST('$f.debounce', function (it) {

        it('should have some tests written', function (assert) {
        });

    });

    // $f.identity(o) -> ?
    TEST('$f.identity', function (it) {

        it('should return the first argument unchanged', function (assert) {

            var o1 = {},
                o2 = {},
                o3 = {};

            assert.isSame($f.identity(o1), o1);
            assert.isSame($f.identity(o2, o3), o2);

        });

    });

    // $f.lock(func[, context[, args]]) -> Function
    TEST('$f.lock', function (it) {

        var func = function (a) {
            return a + this.b;
        };
        var locked = $f.lock(func, {b: 5}, [5]);

        it('should create a function with preset arguments and context', function (assert) {

            assert.isSame(locked(), 10);
            assert.isSame(locked(6), 10);

        });

    });

    // $f.makeConstant(returnValue) -> Function
    TEST('$f.makeConstant', function (it) {

        var retTrue = $f.makeConstant(true);

        it('should always return the set value', function (assert) {

            assert.isTrue(retTrue());
            assert.isTrue(retTrue(false));
            assert.isTrue(retTrue.call(null));
            assert.isTrue(retTrue.call(null, false));

        });

    });

    // $f.noop()
    TEST('$f.noop', function (it) {

        it('should take nothing and return nothing', function (assert) {

            assert.isSame($f.noop(), undefined);
            assert.isSame($f.noop(1), undefined);
            assert.isSame($f.noop.call({}), undefined);
            assert.isSame($f.noop.call({}, 1), undefined);

        });

    });

    // $f.partial(func) -> Function
    // Doesn't work the way I expect - and I wrote the thing! Don't think it's
    // all that useful either.
    /*TEST('$f.partial', function (it) {

        var add = function (a, b) {
                return a + b;
            },

            add5 = $f.partial(add, 5),
            add6 = $f.partial(add, undefined, 6);

        it('should allow arguments to be preset', function (assert) {
            assert.isSame(add5('ignored', 5), 10);
        });

        it('should replace undefined preset arguments', function (assert) {
            assert.isSame(add6(5), 11);
        });

    });*/

    // $f.throttle(func[, wait = 100]) -> Function
    TEST('$f.throttle', function (it) {

        it('should have some tests written', function (assert) {
        });

    });


    TEST('$n.isNumeric', function (it) {

        it('should return true for all number literals', function (assert) {

            assert.isTrue($n.isNumeric(1));
            assert.isTrue($n.isNumeric(1.1));
            assert.isTrue($n.isNumeric(-1));
            assert.isTrue($n.isNumeric(1e4));
            assert.isTrue($n.isNumeric(0xFF));
            assert.isTrue($n.isNumeric(Math.E));
            assert.isTrue($n.isNumeric(Math.LN2));
            assert.isTrue($n.isNumeric(Math.LN10));
            assert.isTrue($n.isNumeric(Math.LOG2E));
            assert.isTrue($n.isNumeric(Math.LOG10E));
            assert.isTrue($n.isNumeric(Math.PI));
            assert.isTrue($n.isNumeric(Math.SQRT1_2));
            assert.isTrue($n.isNumeric(Math.SQRT2));
            assert.isTrue($n.isNumeric(Number.EPSILON));
            assert.isTrue($n.isNumeric(Number.MAX_SAFE_INTEGER));
            assert.isTrue($n.isNumeric(Number.MAX_VALUE));
            assert.isTrue($n.isNumeric(Number.MIN_SAFE_INTEGER));
            assert.isTrue($n.isNumeric(Number.MIN_VALUE));

        });

        it('should return false for all non numeric number constants', function (assert) {

            assert.isFalse($n.isNumeric(NaN));
            assert.isFalse($n.isNumeric(Infinity));
            assert.isFalse($n.isNumeric(Number.NaN));
            assert.isFalse($n.isNumeric(Number.NEGATIVE_INFINITY));
            assert.isFalse($n.isNumeric(Number.POSITIVE_INFINITY));

        });

        it('should return true for numeric strings', function (assert) {

            var Foo = function () {};
            Foo.prototype.toString = function () { return '1'; };
            var foo = new Foo();

            assert.isTrue($n.isNumeric('1'));
            assert.isTrue($n.isNumeric('1.1'));
            assert.isTrue($n.isNumeric('-1'));
            assert.isTrue($n.isNumeric('1e4'));
            assert.isTrue($n.isNumeric('0xFF'));
            assert.isTrue($n.isNumeric(foo));

        });

        it('should return false for non numeric strings and other variable types', function (assert) {

            var Foo = function () {};
            Foo.prototype.toString = function () { return 'one'; };
            var foo = new Foo();

            assert.isFalse($n.isNumeric(''));
            assert.isFalse($n.isNumeric(true));
            assert.isFalse($n.isNumeric('one'));
            assert.isFalse($n.isNumeric([]));
            assert.isFalse($n.isNumeric({}));
            assert.isFalse($n.isNumeric(function () {}));
            assert.isFalse($n.isNumeric(/\s/));
            assert.isFalse($n.isNumeric(null));
            assert.isFalse($n.isNumeric(undefined));
            assert.isFalse($n.isNumeric(1 / 0));
            assert.isFalse($n.isNumeric(foo));

        });

    });

    // $n.times(number, handler[, context]);
    TEST('$n.times', function (it) {

        it('should execute a function a set number of times', function (assert) {

            var num1 = 0,
                num2 = 0,
                num3 = 0;

            $n.times(5,   function () { num1 += 1; });
            $n.times(5.9, function () { num2 += 1; });
            $n.times('5', function () { num3 += 1; });

            assert.isSame(num1, 5);
            assert.isSame(num2, 5);
            assert.isSame(num3, 5);

        });

        it('should pass the number as the argument', function (assert) {

            var num1 = '',
                num2 = '',
                num3 = '';

            $n.times(5,   function (n) { num1 += n; });
            $n.times(5.9, function (n) { num2 += n; });
            $n.times('5', function (n) { num3 += n; });

            assert.isSame(num1, '01234');
            assert.isSame(num2, '01234');
            assert.isSame(num3, '01234');

        });

    });

    // $n.toPosInt(number) -> Number
    TEST('$n.toPosInt', function (it) {

        it('should convert a number to a positive integer', function (assert) {

            assert.isSame($n.toPosInt(1), 1);
            assert.isSame($n.toPosInt(-1), 1);
            assert.isSame($n.toPosInt('1'), 1);
            assert.isSame($n.toPosInt(1.1), 1);
            assert.isSame($n.toPosInt(1.9), 1);
            assert.isSame($n.toPosInt('1.1'), 1);

        });

        it('should convert non numeric arguments to NaN', function (assert) {

            assert.isTrue(isNaN($n.toPosInt('one')));
            assert.isTrue(isNaN($n.toPosInt({})));
            assert.isTrue(isNaN($n.toPosInt(function () {})));
            assert.isTrue(isNaN($n.toPosInt(/\s/)));

            // Undocumented edge case: +[] === 0 so $n.toPosInt([]) === 0;

        });

    });

    // $o.addConfig(object, settings)
    TEST('$o.addConfig', function (it) {

        it('should allow configuration settings to be defined', function (assert) {

            var object = {};

            $o.addConfig(object, {
                foo: true
            });

            assert.isTrue('foo' in object);
            assert.isTrue(Object.prototype.hasOwnProperty.call(object, 'foo'));
            assert.isTrue(object.foo);

        });

        it('should prevent settings being overridden', function (assert) {

            var object = {};

            $o.addConfig(object, {
                foo: true
            });

            assert.isTrue(object.foo);

            try {
                object.foo = false;
            } catch (ignore) {
                // Attempting to override a read-only property can throw errors.
                // Error throwing is not part of the test.
            }

            assert.isTrue(object.foo);

        });

    });

    // $o.clone(object, bitmask = 0) -> Object
    TEST('$o.clone', function (it) {

        it('should copy an object so that changing the first doesn\'t change the second', function (assert) {

            var o1 = {foo: 1, bar: 2, baz: 3},
                o2 = $o.clone(o1),
                ex = {foo: 1, bar: 2, baz: 3};

            assert.isSimilar(o2, ex);

            delete o1.foo;
            assert.isNotSimilar(o1, ex);
            assert.isSimilar(o2, ex);

        });

        it('should allow for deep copies', function (assert) {

            var node = document.createElement('div'),
                o1   = {foo: {bar: true, baz: true, arr: [1, 2, 3], dom: node}},
                o2   = $o.clone(o1),
                o3   = $o.clone(o1, $o.CLONE_DEEP),
                ex   = {foo: {bar: true, baz: true, arr: [1, 2, 3], dom: node}};

            assert.isSimilar(o2, ex);
            assert.isSimilar(o3, ex);

            o1.foo.bar = false;

            assert.isNotSimilar(o2, ex);
            assert.isSimilar(o3, ex);

            assert.isSimilar(o1.foo.arr, o3.foo.arr);
            o1.foo.arr[0] = 4;
            assert.isNotSimilar(o1.foo.arr, o3.foo.arr);
            assert.isSame(o1.foo.dom, o3.foo.dom);

        });

        it('should correctly copy arrays, even deeply', function (assert) {

            var o1 = {arr: [1, 2, 3], foo: {bar: [4, 5, 6]}},
                o2 = $o.clone(o1),
                o3 = $o.clone(o1, $o.CLONE_DEEP),
                ex = {arr: [1, 2, 3], foo: {bar: [4, 5, 6]}};

            assert.isTrue(Array.isArray(o2.arr));
            assert.isTrue(Array.isArray(o2.foo.bar));
            assert.isTrue(Array.isArray(o3.arr));
            assert.isTrue(Array.isArray(o3.foo.bar));

            assert.isSimilar(o2.arr, ex.arr);
            assert.isSimilar(o2.foo.bar, ex.foo.bar);
            assert.isSimilar(o3.arr, ex.arr);
            assert.isSimilar(o3.foo.bar, ex.foo.bar);

            o1.arr[2] = 8;
            o1.foo.bar[2] = 9;

            assert.isNotSimilar(o2.arr, ex.arr);
            assert.isNotSimilar(o2.foo.bar, ex.foo.bar);
            assert.isSimilar(o3.arr, ex.arr);
            assert.isSimilar(o3.foo.bar, ex.foo.bar);

        });

        it('should copy property descriptors if requested', function (assert) {

            var o1 = {};

            Object.defineProperty(o1, 'foo', {
                configurable: true,
                enumerable:   true,
                value:        true,
                writable:     false // read-only
            });

            var o2 = $o.clone(o1);
            var o3 = $o.clone(o1, $o.CLONE_DESC);

            assert.isTrue(o2.foo);
            assert.isTrue(o3.foo);

            try {

                o2.foo = false;
                o3.foo = false;

            } catch (ignore) {
                // Attempting to override a read-only property can throw errors.
                // Error throwing is not part of the test.
            }

            assert.isFalse(o2.foo);
            assert.isTrue(o3.foo);

        });

        it('should copy non enumerable properties only if asked', function (assert) {

            var o1 = {};

            Object.defineProperty(o1, 'foo', {
                configurable: true,
                enumerable:   false,
                value:        true,
                writable:     true
            });

            var o2 = $o.clone(o1);
            var o3 = $o.clone(o1, $o.CLONE_ENUM);

            assert.isSame(o2.foo, undefined);
            assert.isSame(o3.foo, true);

            assert.isFalse('foo' in o2);
            assert.isTrue('foo' in o3);

        });

        it('should allow DOM nodes (and children) to be cloned, if requested', function (assert) {

            var div  = document.createElement('div'),
                span = document.createElement('span'),
                o1   = {node: div},
                o2   = null,
                o3   = null;

            div.appendChild(span);

            o2 = $o.clone(o1);
            o3 = $o.clone(o1, $o.CLONE_NODE);

            assert.isTrue(o2.node instanceof HTMLElement);
            assert.isTrue(o2.node.children[0] instanceof HTMLElement);
            assert.isTrue(o3.node instanceof HTMLElement);
            assert.isTrue(o3.node.children[0] instanceof HTMLElement);

            assert.isSame(o1.node, o2.node);
            assert.isSame(o1.node.children[0], o2.node.children[0]);
            assert.isNotSame(o1.node, o3.node);
            assert.isNotSame(o1.node.children[0], o3.node.children[0]);

        });

        it('should allow the bitmask to be combined', function (assert) {

            var o1 = {};

            Object.defineProperty(o1, 'foo', {
                configurable: true,
                enumerable:   false,
                value:        true,
                writable:     false
            });

            var o2 = $o.clone(o1);
            var o3 = $o.clone(o1, $o.CLONE_ENUM);
            var o4 = $o.clone(o1, $o.CLONE_ENUM | $o.CLONE_DESC);

            assert.isTrue('foo' in o1);
            assert.isFalse('foo' in o2);
            assert.isTrue('foo' in o3);
            assert.isTrue('foo' in o4);

            try {

                o2.foo = false;
                o3.foo = false;
                o4.foo = false;

            } catch (ignore) {
                // Attempting to override a read-only property can throw errors.
                // Error throwing is not part of the test.
            }

            assert.isNotSame(o1.foo, o2.foo);
            assert.isNotSame(o1.foo, o3.foo);
            assert.isSame(o1.foo, o4.foo);

        });

    });

    // $o.each(object, handler[, context])
    TEST('$o.each', function (it) {

        it('should iterate over properties', function (assert) {

            var o1   = {foo: 1, bar: 2, baz: 3},
                num  = 0,
                keys = [];

            $o.each(o1, function (key, value) {

                num += value;
                keys.push(key);

            });

            assert.isSame(num, 6);
            assert.isSame(keys.sort().join('-'), 'bar-baz-foo');

        });

        it('should only iterate over own properties', function (assert) {

            var o1   = {foo: 1, bar: 2, baz: 3},
                o2   = Object.create(o1),
                num  = 0,
                keys = [];

            o2.blip = 4;
            o2.blap = 5;

            $o.each(o2, function (key, value) {

                num += value;
                keys.push(key);

            });

            assert.isSame(num, 9);
            assert.isSame(keys.sort().join('-'), 'blap-blip');

        });

    });

    // $o.extend(object[, extension1 ...]) -> Object
    TEST('$o.extend', function (it) {

        it('should add the properties of objects to another and return the source', function (assert) {

            var o1 = {foo: 1},
                o2 = {bar: 2},
                o3 = $o.extend(o1, o2);

            assert.isTrue('foo' in o1);
            assert.isTrue('bar' in o1);
            assert.isFalse('foo' in o2);
            assert.isSame(o1, o3);

        });

        it('should allow multiple objects to extend the first', function (assert) {

            var o1 = {foo: 1},
                o2 = {bar: 2},
                o3 = {baz: 3},
                o4 = $o.extend(o1, o2, o3);

            assert.isTrue('foo' in o1);
            assert.isTrue('bar' in o1);
            assert.isTrue('baz' in o1);
            assert.isSame(o1, o4);

        });

    });

    // $o.is(value1, value2) -> Boolean
    TEST('$o.is', function (it) {

        it('should work the same as the strict equality operator', function (assert) {

            var o = {},
                a = [];

            assert.isSame(1 === 1, $o.is(1, 1));
            assert.isSame(undefined === undefined, $o.is(undefined, undefined));
            assert.isSame(null === null, $o.is(null, null));
            assert.isSame(o === o, $o.is(o, o));
            assert.isSame(a === a, $o.is(a, a));
            assert.isSame(o === {}, $o.is(o, {}));
            assert.isSame(a === [], $o.is(a, []));

        });

        it('should considered certain number edge-cases equal', function (assert) {

            assert.isTrue($o.is(NaN, NaN));
            assert.isFalse($o.is(0, -0));
            assert.isTrue($o.is(NaN, 0/0));
            assert.isFalse($o.is(NaN, 1/0));

        });

    });

    // $o.isEmpty(object) -> Boolean
    TEST('$o.isEmpty', function (it) {

        it('should detect whether the objects has any own properties', function (assert) {

            var o1 = {foo: 1},
                o2 = {},
                o3 = Object.create(o1);

            assert.isTrue('foo' in o3);
            assert.isTrue($o.isEmpty(o2));
            assert.isTrue($o.isEmpty(o3));
            assert.isFalse($o.isEmpty(o1));

        });

    });

    // $o.keys(object) -> Array
    TEST('$o.keys', function (it) {

        it('should return an array of own keys', function (assert) {

            var o1 = {foo: 1, bar: 2, baz: 3},
                o2 = Object.create(o1);

            assert.isSame($o.keys(o1).sort().join('-'), 'bar-baz-foo');
            assert.isSame($o.keys(o2).sort().join('-'), '');

        });

    });

    // $o.makeMaskCheck(bitmask) -> Function
    TEST('$o.makeMaskCheck', function (it) {

        it('should create a bitmask checker', function (assert) {

            var check = $o.makeMaskCheck(7);

            assert.isTrue(check(1));
            assert.isTrue(check(2));
            assert.isTrue(check(4));
            assert.isFalse(check(8));

        });

    });

    // $o.makeOwns(object) -> Function
    TEST('$o.makeOwns', function (it) {

        it('should make a function that checks if the object contains the given own property', function (assert) {

            var o1    = {foo: 1, bar: 2, baz: 3},
                o2    = Object.create(o1),
                owns1 = $o.makeOwns(o1),
                owns2 = $o.makeOwns(o2);

            assert.isTrue(owns1('foo'));
            assert.isTrue(owns1('bar'));
            assert.isTrue(owns1('baz'));
            assert.isFalse(owns1('blip'));
            assert.isFalse(owns2('foo'));
            assert.isFalse(owns2('bar'));
            assert.isFalse(owns2('baz'));

        });

    });

    // $o.values(object) -> Array
    TEST('$o.values', function (it) {

        it('should return an array of own values', function (assert) {

            var o1 = {foo: 1, bar: 2, baz: 3},
                o2 = Object.create(o1);

            function add(a, b) {
                return a + b;
            }

            assert.isSame($o.values(o1).reduce(add, 0), 6);
            assert.isSame($o.values(o2).reduce(add, 0), 0);

        });

    });

    // $s.clip(string, maxLength, type = $s.CLIP_RIGHT) -> String
    TEST('$s.clip', function (it) {

        it('should reduce a string length to the given amount', function (assert) {

            assert.isSame($s.clip('abcdefg', 5), 'abcde');
            assert.isSame($s.clip('abcdefg', 1), 'a');
            assert.isSame($s.clip('abcdefg', 9), 'abcdefg');

        });

        it('should allow the type of clipping to be defined', function (assert) {

            assert.isSame($s.clip('abcdefg', 5, $s.CLIP_RIGHT), 'abcde');
            assert.isSame($s.clip('abcdefg', 5, $s.CLIP_LEFT),  'cdefg');
            assert.isSame($s.clip('abcdefg', 5, $s.CLIP_RIGHT | $s.CLIP_LEFT), 'bcdef');
            assert.isSame($s.clip('abcdefg', 5, $s.CLIP_BOTH),  'bcdef');
            assert.isSame($s.clip('abcdefg', 4, $s.CLIP_BOTH),  'bcde' );

        });

        it('should normalise the clipping number', function (assert) {

            assert.isSame($s.clip('abcdefg', 5.1), 'abcde');
            assert.isSame($s.clip('abcdefg', 5.9), 'abcde');
            assert.isSame($s.clip('abcdefg', -5),  'abcde');
            assert.isSame($s.clip('abcdefg', '5'), 'abcde');

        });

    });

    // $s.pad(string, minLength, padding = '0', type = $s.PAD_RIGHT) -> String
    TEST('$s.pad', function (it) {

        it('should pad strings out to the given minimum length', function (assert) {

            assert.isSame($s.pad('abcde', 10, '-'), 'abcde-----');
            assert.isSame($s.pad('abcde', 1, '-'), 'abcde');
            assert.isSame($s.pad('abcde', 10), 'abcde00000');

        });

        it('should clip padding as necessary', function (assert) {

            assert.isSame($s.pad('abcde', 10, 'abcde'), 'abcdeabcde');
            assert.isSame($s.pad('abcde',  7, 'abcde'), 'abcdeab');

        });

        it('should pad from the left, right or both as requested', function (assert) {

            assert.isSame($s.pad('abcde', 10, '-', $s.PAD_RIGHT), 'abcde-----');
            assert.isSame($s.pad('abcde', 10, '-', $s.PAD_LEFT ), '-----abcde');
            assert.isSame($s.pad('abcde', 10, '-', $s.PAD_BOTH ), '--abcde---');
            assert.isSame($s.pad('abcde', 10, '-', $s.PAD_RIGHT | $s.PAD_LEFT), '--abcde---');

        });

    });

    // $s.pad(string, times) -> String
    TEST('$s.repeat', function (it) {

        it('should repeat any string the requested number of times', function (assert) {

            assert.isSame($s.repeat('abc', 3), 'abcabcabc');

        });

        it('should normalise the number of times', function (assert) {

            assert.isSame($s.repeat('abc', 3.1), 'abcabcabc');
            assert.isSame($s.repeat('abc', 3.9), 'abcabcabc');
            assert.isSame($s.repeat('abc',  -3), 'abcabcabc');
            assert.isSame($s.repeat('abc', '3'), 'abcabcabc');

        });

    });

    // new $s.Template(string[, pattern])
    TEST('$s.Template', function (it) {

        it('should replace a pattern with the given map', function (assert) {

            var temp1 = new $s.Template('#{foo}'),
                temp2 = new $s.Template('#{foo} #{bar}'),
                temp3 = new $s.Template('#{foo} #{foo}'),
                temp4 = new $s.Template('#{bar}');

            assert.isSame(temp1.evaluate({foo: 'bar'}), 'bar');
            assert.isSame(temp2.evaluate({foo: 'bar', bar: 'baz'}), 'bar baz');
            assert.isSame(temp3.evaluate({foo: 'bar', bar: 'baz'}), 'bar bar');
            assert.isSame(temp4.evaluate({foo: 'bar'}), '#{bar}');

        });

        it('should allow escaped characters and quotation marks', function (assert) {

            var temp1 = new $s.Template('"#{foo}"'),
                temp2 = new $s.Template('\'#{foo}\''),
                temp3 = new $s.Template('\n#{foo}'),
                temp4 = new $s.Template('\\ #{foo}'),
                temp5 = new $s.Template('##{foo}'),
                map   = {foo: 'bar'};

            assert.isSame(temp1.evaluate(map), '"bar"');
            assert.isSame(temp2.evaluate(map), '\'bar\'');
            assert.isSame(temp3.evaluate(map), '\nbar');
            assert.isSame(temp4.evaluate(map), '\\ bar');
            assert.isSame(temp5.evaluate(map), '#bar');

        });

        it('should create reusable templates', function (assert) {

            var temp = new $s.Template('#{foo}');

            assert.isSame(temp.evaluate({foo: 'bar'}), 'bar');
            assert.isSame(temp.evaluate({foo: 'baz'}), 'baz');

        });

        it('should allow string or number replacements and ignore others', function (assert) {

            var temp = new $s.Template('#{foo}');

            assert.isSame(temp.evaluate({foo: 'bar'}), 'bar');
            assert.isSame(temp.evaluate({foo: 1}), '1');
            assert.isSame(temp.evaluate({foo: []}), '#{foo}');
            assert.isSame(temp.evaluate({foo: {}}), '#{foo}');
            assert.isSame(temp.evaluate({foo: function () {}}), '#{foo}');
            assert.isSame(temp.evaluate({foo: null}), '#{foo}');
            assert.isSame(temp.evaluate({foo: undefined}), '#{foo}');

        });

        it('should allow the pattern to be escaped', function (assert) {

            var temp = new $s.Template('#{foo} \\#{foo}');

            assert.isSame(temp.evaluate({foo: 'bar'}), 'bar #{foo}');

        });

        it('should allow a new pattern to be defined', function (assert) {

            var pattern = /(^|.|\r|\n)(\{\{(.*?)\}\})/,
                temp1   = new $s.Template('{{foo}}', pattern),
                temp2   = new $s.Template('{{foo}} #{foo}', pattern),
                temp3   = new $s.Template('{{foo}} \\{{foo}}', pattern);

            assert.isSame(temp1.evaluate({foo: 'bar'}), 'bar');
            assert.isSame(temp2.evaluate({foo: 'bar'}), 'bar #{foo}');
            assert.isSame(temp3.evaluate({foo: 'bar'}), 'bar {{foo}}');

        });

        it('should ignore the new pattern if a non RegExp is passed', function (assert) {

            var temp = new $s.Template('#{foo}', '');

            assert.isSame(temp.evaluate({foo: 'bar'}), 'bar');

        });

    });

    // $s.supplant(string, map[, pattern]) -> String
    TEST('$s.supplant', function (it) {

        it('should be a simple wrapper for new Template', function (assert) {

            var str  = '#{foo}',
                temp = new $s.Template(str),
                map  = {foo: 'bar'};

            assert.isSame($s.supplant(str, map), temp.evaluate(map));

        });

    });

    // $s.uniqid([prefix]) -> String
    TEST('$s.uniqid', function (it) {

        it('should always return a unique ID', function (assert) {

            var id1 = $s.uniqid(),
                id2 = $s.uniqid(),
                id3 = $s.uniqid();

            assert.isNotSame(id1, id2);
            assert.isNotSame(id1, id3);
            assert.isNotSame(id2, id3);

        });

        it('should allow the unique ID to be prefixed', function (assert) {

            var pre = 'Testing prefix',
                id1 = $s.uniqid(pre),
                id2 = $s.uniqid(pre),
                id3 = $s.uniqid(pre);

            assert.isNotSame(id1, id2);
            assert.isNotSame(id1, id3);
            assert.isNotSame(id2, id3);

            assert.isSame(id1.substr(0, pre.length), pre);
            assert.isSame(id2.substr(0, pre.length), pre);
            assert.isSame(id3.substr(0, pre.length), pre);

        });

    });

}());

document.addEventListener('DOMContentLoaded', function () {

    var element = document.getElementById('results'),
        report  = TEST.report(),
        $o      = Core.get('object'),

        map = {
            '$a': 'Array extension',
            '$c': 'Class extension',
            '$f': 'Function extension',
            '$n': 'Number extension',
            '$o': 'Object extension',
            '$s': 'String extension'
        },

        results = {}
    
    $o.each(report, function (test, data) {

        var prefix   = test.substr(0, 2),
            result   = results[prefix],
            analysed = {};

        if (!result) {

            result = results[prefix] = {
                name:    map[prefix],
                results: []
            };

        }

        analysed.name      = test;
        analysed.tests     = data.tests;
        analysed.passes    = data.passes;
        analysed.breakdown = data.assertions;
        analysed.status    = data.assertions.length > 0 ?
                (data.tests === data.passes ? 'pass' : 'fail') :
                'untested';

        result.results.push(analysed);

    });

    $o.each(results, function (prefix, info) {

        var tests  = 0,
            passes = 0;

        info.results.forEach(function (result) {

            tests  += result.tests;
            passes += result.passes;

        });

        results[prefix].tests  = tests;
        results[prefix].passes = passes;

    });

    $o.keys(results).sort().forEach(function (result) {

        var frag = document.createDocumentFragment(),
            data = results[result];

        var title = document.createElement('h2');
        title.appendChild(document.createTextNode(data.name + ' (' + data.passes + ' / ' + data.tests + ')'));

        frag.appendChild(title);

        data.results.forEach(function (result) {

            var dl = document.createElement('dl'),
                dt = document.createElement('dt');

            dt.appendChild(document.createTextNode(result.name + ': ' + result.passes + ' / ' + result.tests + ' = ' + result.status));
            dl.appendChild(dt);

            result.breakdown.forEach(function (info) {

                var dd = document.createElement('dd');
                dd.appendChild(document.createTextNode(info.name + ' (' + info.passes + ' / ' + info.tests + ')'));
                dd.className = info.tests === 0 ? 'is-untested' : info.tests === info.passes ? 'is-pass' : 'is-fail';
                dl.appendChild(dd);

            });

            frag.appendChild(dl);

        });

        element.appendChild(frag);

    });

}, false);
</script>

</head>

<body>

<div id="results">

    <h1>Testing basic extensions</h1>

</div>

</body>
</html>